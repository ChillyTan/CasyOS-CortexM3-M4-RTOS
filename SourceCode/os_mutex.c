/*********************************************************************************************************
* 模块名称：os_mutex.c
* 摘    要：互斥量组件
* 当前版本：1.0.0
* 作    者：Chill
* 完成日期：2026年01月29日
* 内    容：
*           (1) 本模块实现互斥量（Mutex），用于任务间互斥访问共享资源。
*              - 与信号量不同，互斥量具备“所有者(owner)”概念。
*              - 只有 owner 才允许释放互斥量，否则属于非法操作。
*
*           (2) 互斥量数据结构关键成员：
*              - ownerTcb : 当前持有互斥量的任务（NULL 表示空闲）
*              - lockCnt  : 递归加锁计数（支持同一任务重复 Pend）
*              - pendList : 等待该互斥量的任务挂起链表（按优先级唤醒）
*
*           (3) 递归互斥规则：
*              - 若当前任务已持有 mutex，再次 Pend 时 lockCnt++，不会阻塞
*              - Post 时 lockCnt--，只有 lockCnt==0 才真正释放/转移所有权
*
*           (4) 释放策略（Post）：
*              - 若 pendList 为空：互斥量彻底释放（ownerTcb=NULL）
*              - 若 pendList 非空：唤醒最高优先级等待任务，并将 owner 转移给它
*
*           (5) 临界区保护：
*              - ownerTcb / lockCnt / pendList 操作必须在临界区内完成
*              - 防止并发导致互斥量状态损坏或唤醒错误
*
*           (6) 调度时机：
*              - 当 Post 导致更高优先级任务就绪时，退出临界区后调用 OS_Sched()
*              - Pend 导致当前任务挂起后调用 OS_Sched() 切换任务
*
*           (7) 设计限制：
*              - TODO: 当前实现未包含优先级继承（Priority Inheritance）
*                若高优先级任务等待低优先级任务持有的 mutex，可能发生优先级反转
**********************************************************************************************************
* 取代版本：
* 作    者：
* 完成日期：
* 修改内容：
* 修改文件：
*********************************************************************************************************/

/*********************************************************************************************************
*                                              包含头文件
*********************************************************************************************************/
#include "CasyOS.h"

#if OS_CFG_MUTEX_EN != 0
/*********************************************************************************************************
*                                              宏定义
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部变量
*********************************************************************************************************/
extern OS_TASK_HANDLE *g_pCurrentTask;

/*********************************************************************************************************
*                                              内部函数声明
*********************************************************************************************************/

/*********************************************************************************************************
*                                              枚举结构体
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称：
* 函数功能：
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：
* 注    意：
*********************************************************************************************************/


/*********************************************************************************************************
*                                              API函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称：OSMutexCreate
* 函数功能：创建互斥量
* 输入参数：p_mutex: 互斥量指针 p_name: 互斥量名称字符串
* 输出参数：void
* 返 回 值：void
* 创建日期：2026年01月29日
* 注    意：
*           (1) 创建后互斥量处于空闲状态：ownerTcb=NULL，lockCnt=0
*           (2) pendList 初始化为空链表
*           (3) 本函数仅初始化对象，不分配额外内存
*********************************************************************************************************/
void OSMutexCreate(OS_MUTEX *p_mutex, u8* p_name)
{
	p_mutex->objType = OS_OBJ_TYPE_MUTEX;
	p_mutex->pendList.headPtr = NULL;
	p_mutex->pendList.tailPtr = NULL;
	p_mutex->name = p_name;
	p_mutex->ownerTcb = NULL;
	p_mutex->lockCnt = 0;
}

/*********************************************************************************************************
* 函数名称：OSMutexPost
* 函数功能：释放互斥量
* 输入参数：p_mutex: 互斥量指针
* 输出参数：void
* 返 回 值：void
* 创建日期：2026年01月29日
* 注    意：
*           (1) 只有互斥量 owner 才允许释放，否则报错并返回
*
*           (2) 递归释放：
*              - 每次 Post 会先将 lockCnt-- 
*              - lockCnt>0 表示仍然持有互斥量，不会释放给其他任务
*
*           (3) 当 lockCnt==0 时表示真正释放：
*              - 若 pendList 为空：ownerTcb=NULL，互斥量空闲
*              - 若 pendList 非空：唤醒最高优先级等待任务，并转移 owner 给它
*                同时将 lockCnt 置为 1
*
*           (4) 若释放导致更高优先级任务就绪，则退出临界区后调用 OS_Sched()
*********************************************************************************************************/
void OSMutexPost(OS_MUTEX *p_mutex)
{
	OS_TASK_HANDLE *p_tcb;
	OS_PEND_LIST *p_pend_list;
	
	OS_ENTER_CRITICAL();
	
	//互斥量为空或无效
	if(p_mutex == NULL || p_mutex->objType != OS_OBJ_TYPE_MUTEX)
	{
		printf("ERROR:[OSMutexPost] Illegal argument!\r\n");
		return;
	}
	
	//互斥量所有者不是当前任务
	if (p_mutex->ownerTcb != g_pCurrentTask)
	{
		printf("ERROR:[OSMutexPost] Not Mutex's Owner!\r\n");
		OS_EXIT_CRITICAL();
		return;
	}

	//递归释放：先减计数
	if(p_mutex->lockCnt > 0)
	{
		p_mutex->lockCnt--;
	}

	//lockCnt 还没到 0：仍然持有 mutex，不允许释放给别人
	if(p_mutex->lockCnt > 0)
	{
		OS_EXIT_CRITICAL();
		return;
	}

	//真正释放/转移所有权
	p_pend_list = &p_mutex->pendList;

	if(p_pend_list->headPtr == NULL)
	{
		//无等待者：彻底释放
		p_mutex->ownerTcb = NULL;
		//lockCnt 已经是 0
		OS_EXIT_CRITICAL();
		return;
	}
	else
	{
		//有等待者：转移给最高优先级任务
		p_tcb = OS_PendListGetHighest(p_pend_list);
		OS_PendListRemove(p_pend_list, p_tcb);

		p_tcb->state   = OS_TASK_READY;
		p_tcb->pendObj = NULL;
		OS_RdyTaskAdd(p_tcb);

		p_mutex->ownerTcb = p_tcb;
		p_mutex->lockCnt  = 1;   //新 owner 获得一次锁

		OS_EXIT_CRITICAL();
		OS_Sched();
		return;
	}
}

/*********************************************************************************************************
* 函数名称：OSMutexPend
* 函数功能：挂起等待互斥量
* 输入参数：p_mutex: 互斥量指针
* 输出参数：void
* 返 回 值：void
* 创建日期：2026年01月29日
* 注    意：
*           (1) 若互斥量空闲（ownerTcb==NULL && lockCnt==0）：
*              - 当前任务成为 owner
*              - lockCnt=1，立即返回
*
*           (2) 若互斥量已被当前任务持有（递归加锁）：
*              - lockCnt++，立即返回（不会阻塞）
*
*           (3) 若互斥量被其他任务持有：
*              - 当前任务从就绪表移除
*              - 插入 mutex 的 pendList
*              - state=OS_TASK_PEND，pendObj 指向该 mutex
*              - 调用 OS_Sched() 切换任务
*
*           (4) TODO: 本实现不支持超时等待，如需超时需结合 Tick 扩展
*********************************************************************************************************/
void OSMutexPend(OS_MUTEX *p_mutex)
{
	OS_ENTER_CRITICAL();
	
	//互斥量为空或无效
	if(p_mutex == NULL || p_mutex->objType != OS_OBJ_TYPE_MUTEX)
	{
		printf("ERROR:[OSMutexPend] Illegal argument!\r\n");
		return;
	}
	
	//如果互斥量空闲
	if(p_mutex->ownerTcb == NULL && p_mutex->lockCnt == 0)
	{
		p_mutex->ownerTcb = g_pCurrentTask;
		p_mutex->lockCnt = 1;	//标记上锁一次
		OS_EXIT_CRITICAL();
		return;
	}
	
	//如果互斥量已经被自己上过锁(递归上锁情况)
	if(p_mutex->ownerTcb == g_pCurrentTask)	//没有可用的资源 挂起任务等待
	{
		p_mutex->lockCnt++;
		OS_EXIT_CRITICAL();
		return;
	}
	
	//如果被其他任务上锁
	OS_RdyTaskRemove(g_pCurrentTask);
	OS_PendListInsert(&p_mutex->pendList, g_pCurrentTask);
	g_pCurrentTask->state = OS_TASK_PEND;
	g_pCurrentTask->pendObj = (void*)p_mutex;
	
	//挂起任务
	OS_EXIT_CRITICAL();
	OS_Sched();
}

#endif //OS_CFG_MUTEX_EN
