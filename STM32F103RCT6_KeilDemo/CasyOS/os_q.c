/*********************************************************************************************************
* 模块名称: os_q.c
* 摘    要: 消息队列模块
* 当前版本: 1.0.0
* 作    者: Chill
* 完成日期: 2026年01月15日 
* 内    容:
*           (1) 本模块实现“内建消息队列”(Built-in Queue)：
*              - 每个任务 OS_TASK_HANDLE 内部自带一个 OS_Q 对象（msgQueue）
*              - 队列存储区由 OS_QInit() 动态分配（OSMalloc）
*
*           (2) 数据组织形式：
*              - msgBase 指向环形缓冲区（循环队列）
*              - inIdx  指向写入位置
*              - outIdx 指向读取位置
*              - count  表示当前缓冲区内消息数量
*              - countMax 表示缓冲区最大容量（单位：消息个数）
*
*           (3) 快速投递机制（Direct Post）：
*              - 若接收任务正在挂起等待该队列（state==PEND 且 pendObj==p_que）
*                则发送方不进入环形缓冲区，而是直接写入接收任务的 msgTemp
*                并将其唤醒进入 READY，触发调度。
*
*           (4) 临界区保护：
*              - 队列入队/出队、count/inIdx/outIdx 更新属于共享资源操作
*              - 必须在临界区内完成以避免并发破坏队列结构
*
*           (5) 阻塞等待机制：
*              - OSQPend() 在队列无数据时会挂起当前任务
*              - 被 OSQPost() 唤醒后，从 msgTemp 取回消息
*
*           (6) 设计限制：
*              - 本实现固定以 4 字节(u32) 作为消息传递单位（值传递）
*              - 若需要传递结构体/大块数据, 建议将指针强制转换为 u32 来传递指针, 并自行管理生命周期
**********************************************************************************************************
* 取代版本: 
* 作    者:
* 完成日期: 
* 修改内容:
* 修改文件: 
*********************************************************************************************************/

/*********************************************************************************************************
*                                              包含头文件
*********************************************************************************************************/
#include "CasyOS.h"

#if OS_CFG_Q_EN != 0
/*********************************************************************************************************
*                                              宏定义
*********************************************************************************************************/

/*********************************************************************************************************
*                                              枚举结构体
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部变量定义
*********************************************************************************************************/
extern OS_TASK_HANDLE *g_pCurrentTask;

/*********************************************************************************************************
*                                              内部函数声明
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称: 
* 函数功能: 
* 输入参数: 
* 输出参数: void
* 返 回 值: void
* 创建日期: 2026年01月27日
* 注    意:
*********************************************************************************************************/

/*********************************************************************************************************
*                                              API函数实现
*********************************************************************************************************/
/*********************************************************************************************************
* 函数名称: OS_QInit
* 函数功能: 队列初始化
* 输入参数: 任务句柄 消息队列长度
* 输出参数: void
* 返 回 值: void
* 创建日期: 2026年01月27日
* 注    意: 
*						(1) 非用户调用 内核其他部分使用
*           (2) 本队列为“内建消息队列”，每个任务自带一个 msgQueue
*           (3) 队列存储空间由 OSMalloc() 分配，msgBase 指向环形缓冲区
*           (4) 初始化后队列为空：count=0，inIdx=0，outIdx=0
*********************************************************************************************************/
void OS_QInit(OS_TASK_HANDLE* p_tcb, u32 countMax)
{
	OS_Q *p_que;
	if(p_tcb == NULL)
	{
		printf("ERROR:[OS_QInit] Illegal argument!\r\n");
		return;
	}
	
	if(countMax == 0)
	{
		return;
	}
	
	p_que = &p_tcb->msgQueue;
	
	p_que->objType = OS_OBJ_TYPE_Q;
	p_que->msgBase = OSMalloc(countMax);
	if(p_que->msgBase == NULL)
	{
		printf("ERROR:[OS_QInit] Malloc Failed!\r\n");
		while(1){}
	}
	p_que->countMax = countMax;
	p_que->count = 0;
	p_que->inIdx = 0;
	p_que->outIdx = 0;
}

/*********************************************************************************************************
* 函数名称: OSQPost
* 函数功能: 按照4字节发送消息到队列
* 输入参数: 需要发送到的任务句柄 4字节消息
* 输出参数: void
* 返 回 值: void
* 创建日期: 2026年01月27日
* 注    意: 
*           (1) 若接收任务正在等待该队列（PEND + pendObj==该队列）
*               则采用“直接投递”：
*              - msg 写入接收任务的 msgTemp
*              - 将任务转为 READY 并加入就绪表
*              - 调用 OS_Sched() 触发调度
*
*           (2) 若接收任务未等待，则消息进入环形缓冲区：
*              - msgBase[inIdx] = msg
*              - inIdx 循环递增
*              - count++
*
*           (3) 队列满时（count >= countMax）：
*              - 当前实现直接丢弃消息，并打印 Warning
*
*           (4) 本函数涉及队列/任务状态修改，必须在临界区内完成
*********************************************************************************************************/
void OSQPost(OS_TASK_HANDLE* p_tcb, u32 msg)
{
	OS_Q *p_que;
	
  OS_ENTER_CRITICAL();
	
  if(p_tcb == NULL)
	{
		printf("ERROR:[OSQPost] Illegal argument!\r\n");
		return;
	}

	p_que = &p_tcb->msgQueue;
  //检查接收方任务是否在挂起等待消息
	if(p_tcb->state == OS_TASK_PEND && p_tcb->pendObj == (void*)p_que)
	{
		//将消息直接放入该任务的 TCB 预留变量中
		p_tcb->msgTemp = msg;
		p_tcb->state = OS_TASK_READY;
		p_tcb->pendObj = NULL;
		OS_RdyTaskAdd(p_tcb);
		OS_EXIT_CRITICAL();
		
		//触发调度
		OS_Sched(); 
		return;
	}

	//若无任务等待 存入环形缓冲区
	if(p_que->count < p_que->countMax) //如果没满
	{
		p_que->msgBase[p_que->inIdx] = msg;
		p_que->inIdx = (p_que->inIdx + 1) % p_que->countMax;
		p_que->count++;
	}
	else	//如果满了
	{
		printf("Warning: [OSQPost] Queue Full!\r\n");
	}

  OS_EXIT_CRITICAL();
}

/*********************************************************************************************************
* 函数名称: OSQPend
* 函数功能: 按照指定的大小获取消息队列消息
* 输入参数: void
* 输出参数: 接受消息的地址
* 返 回 值: void
* 创建日期: 2026年01月27日
* 注    意:
*           (1) 若队列中有数据（count>0）：
*              - 直接从 msgBase[outIdx] 取出消息
*              - outIdx 循环递增
*              - count--
*              - 不发生任务切换，立即返回
*
*           (2) 若队列为空（count==0）：
*              - 挂起当前任务 state=OS_TASK_PEND
*              - pendObj 指向自身 msgQueue
*              - 从就绪表移除并调用 OS_Sched() 切换任务
*
*           (3) 当被 OSQPost() 唤醒后：
*              - 消息已由发送方写入 g_pCurrentTask->msgTemp
*              - 本函数从 msgTemp 取出消息返回给用户
*
*           (4) TODO: 本实现不支持超时等待，若需要超时需结合 Tick/延时机制扩展
*********************************************************************************************************/
void OSQPend(u32 *p_msg)
{
	OS_Q *p_que;
	
	OS_ENTER_CRITICAL();
	
	//检查输入参数
	if(p_msg == NULL)
	{
		printf("ERROR:[OSQPend] Illegal argument!\r\n");
		return;
	}

	//检查消息队列中是否有消息可以获取
	p_que = &g_pCurrentTask->msgQueue;
	if(p_que->count > 0)
	{
		*p_msg = p_que->msgBase[p_que->outIdx];
		p_que->outIdx = (p_que->outIdx + 1) % p_que->countMax;
		p_que->count--;
		OS_EXIT_CRITICAL();
		return;
	}

	//缓冲区无数据 挂起当前任务
	g_pCurrentTask->state = OS_TASK_PEND;
	g_pCurrentTask->pendObj = &g_pCurrentTask->msgQueue;
	OS_RdyTaskRemove(g_pCurrentTask);
	
	OS_EXIT_CRITICAL();
	OS_Sched(); 

	//当任务被 OSQPost 唤醒回到这里时 消息已存放在 TCB 中
	*p_msg = g_pCurrentTask->msgTemp;
}

/*********************************************************************************************************
* 函数名称: OSQFlush
* 函数功能: 清空消息队列中的消息
* 输入参数: 需要清空消息的任务句柄
* 输出参数: void
* 返 回 值: void
* 创建日期: 2026年01月27日
* 注    意:
*           (1) 清空操作仅重置 count/inIdx/outIdx，不释放 msgBase 内存
*           (2) 清空后队列立即为空，后续接收需要重新等待/接收
*           (3) 操作队列变量需在临界区内完成
*********************************************************************************************************/
void OSQFlush(OS_TASK_HANDLE* p_tcb)
{
	OS_Q *p_que;
	OS_ENTER_CRITICAL();
	p_que = &p_tcb->msgQueue;
	p_que->count  = 0;
	p_que->inIdx  = 0;
	p_que->outIdx = 0;
	OS_EXIT_CRITICAL();
}

/*********************************************************************************************************
* 函数名称: OSQGetCount / OSQIsEmpty / OSQIsFull
* 函数功能: 获取队列中消息数量 / 判断消息队列空 / 判断消息队列满
* 输入参数: p_tcb: 任务句柄指针
* 输出参数: void
* 返 回 值: OSQGetCount(): 当前队列消息数量
*          OSQIsEmpty():  1=空 0=非空
*          OSQIsFull():   1=满 0=未满
* 创建日期: 2026年01月27日
* 注    意: 
*           (1) 本函数未加临界区保护, 若在多任务并发环境下频繁访问, 建议在调用者侧进入临界区或提供带保护版本
*********************************************************************************************************/
u32	OSQGetCount(OS_TASK_HANDLE* p_tcb) { return p_tcb->msgQueue.count; }
u8	OSQIsEmpty(OS_TASK_HANDLE* p_tcb)  { return (p_tcb->msgQueue.count == 0); }
u8	OSQIsFull(OS_TASK_HANDLE* p_tcb)   { return (p_tcb->msgQueue.count >= p_tcb->msgQueue.countMax); }

#endif	//OS_CFG_Q_EN
